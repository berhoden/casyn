<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>casyn.api documentation</title></head><body><div id="header"><h1><a href="index.html">Casyn 0.1.6-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="casyn.api.html"><span>casyn.api</span></a></li><li><a href="casyn.auto-discovery.html"><span>casyn.auto-discovery</span></a></li><li><a href="casyn.balancer.html"><span>casyn.balancer</span></a></li><li><a href="casyn.balancer.least-loaded.html"><span>casyn.balancer.least-loaded</span></a></li><li><a href="casyn.balancer.round-robin.html"><span>casyn.balancer.round-robin</span></a></li><li><a href="casyn.client.html"><span>casyn.client</span></a></li><li><a href="casyn.cluster.html"><span>casyn.cluster</span></a></li><li><a href="casyn.cluster.core.html"><span>casyn.cluster.core</span></a></li><li><a href="casyn.codecs.html"><span>casyn.codecs</span></a></li><li><a href="casyn.core.html"><span>casyn.core</span></a></li><li><a href="casyn.ddl.html"><span>casyn.ddl</span></a></li><li><a href="casyn.pool.html"><span>casyn.pool</span></a></li><li><a href="casyn.pool.commons.html"><span>casyn.pool.commons</span></a></li><li><a href="casyn.schema.html"><span>casyn.schema</span></a></li><li><a href="casyn.types.html"><span>casyn.types</span></a></li><li><a href="casyn.utils.html"><span>casyn.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="casyn.api.html#var-batch-mutate"><span>batch-mutate</span></a></li><li><a href="casyn.api.html#var-column"><span>column</span></a></li><li><a href="casyn.api.html#var-column-parent"><span>column-parent</span></a></li><li><a href="casyn.api.html#var-column-path"><span>column-path</span></a></li><li><a href="casyn.api.html#var-delete"><span>delete</span></a></li><li><a href="casyn.api.html#var-delete-mutation"><span>delete-mutation</span></a></li><li><a href="casyn.api.html#var-describe-cluster-name"><span>describe-cluster-name</span></a></li><li><a href="casyn.api.html#var-describe-keyspace"><span>describe-keyspace</span></a></li><li><a href="casyn.api.html#var-describe-keyspaces"><span>describe-keyspaces</span></a></li><li><a href="casyn.api.html#var-describe-partitioner"><span>describe-partitioner</span></a></li><li><a href="casyn.api.html#var-describe-ring"><span>describe-ring</span></a></li><li><a href="casyn.api.html#var-describe-schema-versions"><span>describe-schema-versions</span></a></li><li><a href="casyn.api.html#var-describe-snitch"><span>describe-snitch</span></a></li><li><a href="casyn.api.html#var-describe-splits"><span>describe-splits</span></a></li><li><a href="casyn.api.html#var-describe-token-map"><span>describe-token-map</span></a></li><li><a href="casyn.api.html#var-describe-version"><span>describe-version</span></a></li><li><a href="casyn.api.html#var-execute-cql-query"><span>execute-cql-query</span></a></li><li><a href="casyn.api.html#var-execute-prepared-cql-query"><span>execute-prepared-cql-query</span></a></li><li><a href="casyn.api.html#var-get-column"><span>get-column</span></a></li><li><a href="casyn.api.html#var-get-count"><span>get-count</span></a></li><li><a href="casyn.api.html#var-get-indexed-slice"><span>get-indexed-slice</span></a></li><li><a href="casyn.api.html#var-get-paged-slice"><span>get-paged-slice</span></a></li><li><a href="casyn.api.html#var-get-range-slice"><span>get-range-slice</span></a></li><li><a href="casyn.api.html#var-get-row"><span>get-row</span></a></li><li><a href="casyn.api.html#var-get-rows"><span>get-rows</span></a></li><li><a href="casyn.api.html#var-get-slice"><span>get-slice</span></a></li><li><a href="casyn.api.html#var-increment"><span>increment</span></a></li><li><a href="casyn.api.html#var-index-clause"><span>index-clause</span></a></li><li><a href="casyn.api.html#var-index-expressions"><span>index-expressions</span></a></li><li><a href="casyn.api.html#var-insert-column"><span>insert-column</span></a></li><li><a href="casyn.api.html#var-key-range"><span>key-range</span></a></li><li><a href="casyn.api.html#var-login"><span>login</span></a></li><li><a href="casyn.api.html#var-mget-count"><span>mget-count</span></a></li><li><a href="casyn.api.html#var-mget-slice"><span>mget-slice</span></a></li><li><a href="casyn.api.html#var-mutation"><span>mutation</span></a></li><li><a href="casyn.api.html#var-prepare-cql-query"><span>prepare-cql-query</span></a></li><li><a href="casyn.api.html#var-put"><span>put</span></a></li><li><a href="casyn.api.html#var-set-cql-version"><span>set-cql-version</span></a></li><li><a href="casyn.api.html#var-set-keyspace"><span>set-keyspace</span></a></li><li><a href="casyn.api.html#var-slice-predicate"><span>slice-predicate</span></a></li><li><a href="casyn.api.html#var-truncate"><span>truncate</span></a></li><li><a href="casyn.api.html#var-with-client"><span>with-client</span></a></li><li><a href="casyn.api.html#var-with-client2"><span>with-client2</span></a></li><li><a href="casyn.api.html#var-with-consistency"><span>with-consistency</span></a></li><li><a href="casyn.api.html#var-wrap-result-channel"><span>wrap-result-channel</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>casyn.api documentation</h2><pre class="doc">Thrift API and related utils. Most of the fns here translate almost directly
to their thrift counterpart and most of the time return Thrift instances.
See: http://wiki.apache.org/cassandra/API 
and
http://javasourcecode.org/html/open-source/cassandra/cassandra-0.8.1/org/apache/cassandra/thrift/Cassandra.AsyncClient.html</pre><div class="public" id="var-batch-mutate"><h3>batch-mutate</h3><div class="usage"><code>(batch-mutate client mutations &amp; {:keys [consistency]})</code></div><pre class="doc">
</pre></div><div class="public" id="var-column"><h3>column</h3><div class="usage"><code>(column name value &amp; {:keys [type ttl timestamp], :or {type :column}})</code></div><pre class="doc">Returns a Thrift Column instance
</pre></div><div class="public" id="var-column-parent"><h3>column-parent</h3><div class="usage"><code>(column-parent cf &amp; [super])</code></div><pre class="doc">Returns a Thrift ColumnParent instance, works for common columns or
super columns depending on arity used</pre></div><div class="public" id="var-column-path"><h3>column-path</h3><div class="usage"><code>(column-path cf &amp; {:keys [super column]})</code><code>(column-path cf)</code></div><pre class="doc">Returns a Thrift ColumnPath instance, works for common columns or
super columns depending on arity used</pre></div><div class="public" id="var-delete"><h3>delete</h3><div class="usage"><code>(delete client cf row-key &amp; {:keys [column super timestamp consistency type], :or {timestamp (utils/ts)}})</code></div><pre class="doc">
</pre></div><div class="public" id="var-delete-mutation"><h3>delete-mutation</h3><div class="usage"><code>(delete-mutation &amp; {:keys [super], :as opts})</code></div><pre class="doc">Accepts optional slice-predicate arguments :columns, :start, :finish, :count,
:reversed, if you specify :columns the other slice args will be ignored (as
defined by thrift)
The :super key and specify a supercolumn name</pre></div><div class="public" id="var-describe-cluster-name"><h3>describe-cluster-name</h3><div class="usage"><code>(describe-cluster-name client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-keyspace"><h3>describe-keyspace</h3><div class="usage"><code>(describe-keyspace client ks)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-keyspaces"><h3>describe-keyspaces</h3><div class="usage"><code>(describe-keyspaces client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-partitioner"><h3>describe-partitioner</h3><div class="usage"><code>(describe-partitioner client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-ring"><h3>describe-ring</h3><div class="usage"><code>(describe-ring client ks)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-schema-versions"><h3>describe-schema-versions</h3><div class="usage"><code>(describe-schema-versions client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-snitch"><h3>describe-snitch</h3><div class="usage"><code>(describe-snitch client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-splits"><h3>describe-splits</h3><div class="usage"><code>(describe-splits client cf start-token end-token keys-per-split)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-token-map"><h3>describe-token-map</h3><div class="usage"><code>(describe-token-map client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-describe-version"><h3>describe-version</h3><div class="usage"><code>(describe-version client)</code></div><pre class="doc">
</pre></div><div class="public" id="var-execute-cql-query"><h3>execute-cql-query</h3><div class="usage"><code>(execute-cql-query client query &amp; {:keys [schema output]})</code></div><pre class="doc">
</pre></div><div class="public" id="var-execute-prepared-cql-query"><h3>execute-prepared-cql-query</h3><div class="usage"><code>(execute-prepared-cql-query client item-id values &amp; {:keys [schema output]})</code></div><pre class="doc">
</pre></div><div class="public" id="var-get-column"><h3>get-column</h3><div class="usage"><code>(get-column client cf row-key c &amp; {:keys [super consistency schema output]})</code></div><pre class="doc">
</pre></div><div class="public" id="var-get-count"><h3>get-count</h3><div class="usage"><code>(get-count client cf row-key &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Accepts optional slice-predicate arguments :columns, :start, :finish, :count,
:reversed, if you specify :columns the other slice args will be ignored (as
defined by the cassandra api)</pre></div><div class="public" id="var-get-indexed-slice"><h3>get-indexed-slice</h3><div class="usage"><code>(get-indexed-slice client cf index-clause-args &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Accepts optional slice-predicate arguments :columns, :start, :finish, :count,
:reversed, if you specify :columns the other slice args will be ignored (as
defined by the cassandra api)</pre></div><div class="public" id="var-get-paged-slice"><h3>get-paged-slice</h3><div class="usage"><code>(get-paged-slice client cf &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Accepts optional key-range arguments :start-token :start-key :end-token
:end-key :count-key :row-filter (vector of index-expressions) and takes an additional :start-column name</pre></div><div class="public" id="var-get-range-slice"><h3>get-range-slice</h3><div class="usage"><code>(get-range-slice client cf &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Accepts optional slice-predicate arguments :columns, :start, :finish, :count,
:reversed, if you specify :columns the other slice args will be ignored (as
defined by the cassandra api). Accepts optional key-range arguments :start-token
:start-key :end-token :end-key :count-key :row-filter (vector of index-expressions)</pre></div><div class="public" id="var-get-row"><h3>get-row</h3><div class="usage"></div><pre class="doc">Alias to get-slice
</pre></div><div class="public" id="var-get-rows"><h3>get-rows</h3><div class="usage"></div><pre class="doc">Alias to mget-slice
</pre></div><div class="public" id="var-get-slice"><h3>get-slice</h3><div class="usage"><code>(get-slice client cf row-key &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Returns a slice of columns. Accepts optional slice-predicate arguments :columns, :start, :finish, :count,
:reversed, if you specify :columns the other slice args will be
ignored (as defined by the cassandra api)</pre></div><div class="public" id="var-increment"><h3>increment</h3><div class="usage"><code>(increment client cf row-key column-name value &amp; {:keys [super consistency]})</code></div><pre class="doc">
</pre></div><div class="public" id="var-index-clause"><h3>index-clause</h3><div class="usage"><code>(index-clause expressions &amp; {:keys [start-key count], :or {count 100}})</code></div><pre class="doc">Defines one or more IndexExpressions for get_indexed_slices. An
IndexExpression containing an EQ IndexOperator must be present</pre></div><div class="public" id="var-index-expressions"><h3>index-expressions</h3><div class="usage"><code>(index-expressions expressions)</code></div><pre class="doc">Returns and IndexExpression instance for a sequence of clauses:
Ex: [[:eq? :foo &quot;bar&quot;]
     [:gt? &quot;baz&quot; 1]]</pre></div><div class="public" id="var-insert-column"><h3>insert-column</h3><div class="usage"><code>(insert-column client cf row-key name value &amp; {:keys [super type consistency ttl timestamp], :or {type :column}})</code></div><pre class="doc">
</pre></div><div class="public" id="var-key-range"><h3>key-range</h3><div class="usage"><code>(key-range {:keys [start-token start-key end-token end-key count-key row-filter]})</code></div><pre class="doc">Returns a Thrift KeyRange instance for a range of keys, row-filter
accepts a sequence of index expressions, see index-expression</pre></div><div class="public" id="var-login"><h3>login</h3><div class="usage"><code>(login client auth-req)</code></div><pre class="doc">
</pre></div><div class="public" id="var-mget-count"><h3>mget-count</h3><div class="usage"><code>(mget-count client cf row-keys &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Accepts optional slice-predicate arguments :columns, :start, :finish, :count,
:reversed, if you specify :columns the other slice args will be ignored (as
defined by the cassandra api)</pre></div><div class="public" id="var-mget-slice"><h3>mget-slice</h3><div class="usage"><code>(mget-slice client cf row-keys &amp; {:keys [super consistency schema output], :as opts})</code></div><pre class="doc">Returns a collection of slices of columns.
Accepts optional slice-predicate
arguments :columns, :start, :finish, :count, :reversed, if you
specify :columns the other slice args will be ignored (as defined by the cassandra api)</pre></div><div class="public" id="var-mutation"><h3>mutation</h3><div class="usage"><code>(mutation name value &amp; {:keys [type ttl timestamp]})</code></div><pre class="doc">Takes column name, and value + optional :type that can have the
following  values :column (default) :super :counter :counter-super. :ttl
and :timestamp options are also available when dealing with super or
regular columns, otherwise ignored.</pre></div><div class="public" id="var-prepare-cql-query"><h3>prepare-cql-query</h3><div class="usage"><code>(prepare-cql-query client query)</code></div><pre class="doc">
</pre></div><div class="public" id="var-put"><h3>put</h3><div class="usage"><code>(put client cf row-key columns &amp; {:keys [consistency type]})</code></div><pre class="doc">Accepts cols as vectors or maps to be applied to cols
constructors (use maps for simple key vals, use vectors if you need
to set ttl or timestamp</pre></div><div class="public" id="var-set-cql-version"><h3>set-cql-version</h3><div class="usage"><code>(set-cql-version client version)</code></div><pre class="doc">
</pre></div><div class="public" id="var-set-keyspace"><h3>set-keyspace</h3><div class="usage"><code>(set-keyspace client ks)</code></div><pre class="doc">
</pre></div><div class="public" id="var-slice-predicate"><h3>slice-predicate</h3><div class="usage"><code>(slice-predicate {:keys [columns start finish reversed count]})</code></div><pre class="doc">Returns a SlicePredicate instance, takes a map, it can be either for named keys
using the :columns key, or a range defined from :start :finish :reversed :count
Ex: (slice-predicate {:columns [&quot;foo&quot; &quot;bar&quot;]})
    (slice-predicate :start 100 :finish 200 :reversed true :count 10)</pre></div><div class="public" id="var-truncate"><h3>truncate</h3><div class="usage"><code>(truncate client cf)</code></div><pre class="doc">
</pre></div><div class="public" id="var-with-client"><h3>with-client</h3><div class="usage"><code>(with-client client &amp; body)</code></div><pre class="doc">Binds client for the enclosed body, won't work if the body contains
partial or apply of api functions, if you need to handle this cases
you will have to pass *client* explicitly. This is a second class
citizen macro, should probably be avoided and use the regular (c-fn
api-call args) form</pre></div><div class="public" id="var-with-client2"><h3>with-client2</h3><div class="usage"><code>(with-client2 client &amp; body)</code></div><pre class="doc">Same as the with-client but supports apply/partial, slower though (cost of a
partial call)</pre></div><div class="public" id="var-with-consistency"><h3>with-consistency</h3><div class="usage"><code>(with-consistency consistency &amp; body)</code></div><pre class="doc">Binds consistency level for the enclosed body
</pre></div><div class="public" id="var-wrap-result-channel"><h3>wrap-result-channel</h3><div class="usage"><code>(wrap-result-channel form &amp; post-realize-fns)</code></div><pre class="doc">Wraps a form in a Lamina result-channel, and make the last arg of the form an
AsyncMethodCallback with error/complete callback bound to a result-channel</pre></div></div></body></html>